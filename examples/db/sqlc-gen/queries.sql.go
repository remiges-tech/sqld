// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEmployee = `-- name: GetEmployee :one
SELECT id, first_name, last_name, email, phone, hire_date, salary, department, position, is_active, created_at, updated_at FROM employees WHERE id = $1
`

func (q *Queries) GetEmployee(ctx context.Context, id int64) (Employee, error) {
	row := q.db.QueryRow(ctx, getEmployee, id)
	var i Employee
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.HireDate,
		&i.Salary,
		&i.Department,
		&i.Position,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEmployeesAdvanced = `-- name: GetEmployeesAdvanced :many
SELECT 
    id, 
    first_name, 
    last_name, 
    department, 
    salary
FROM employees
WHERE 
    department = $1
    AND salary >= $2
    AND salary <= $3
ORDER BY salary DESC
`

type GetEmployeesAdvancedParams struct {
	Department pgtype.Text    `db:"department" json:"department"`
	MinSalary  pgtype.Numeric `db:"min_salary" json:"min_salary"`
	MaxSalary  pgtype.Numeric `db:"max_salary" json:"max_salary"`
}

type GetEmployeesAdvancedRow struct {
	ID         int64          `db:"id" json:"id"`
	FirstName  string         `db:"first_name" json:"first_name"`
	LastName   string         `db:"last_name" json:"last_name"`
	Department pgtype.Text    `db:"department" json:"department"`
	Salary     pgtype.Numeric `db:"salary" json:"salary"`
}

func (q *Queries) GetEmployeesAdvanced(ctx context.Context, arg GetEmployeesAdvancedParams) ([]GetEmployeesAdvancedRow, error) {
	rows, err := q.db.Query(ctx, getEmployeesAdvanced, arg.Department, arg.MinSalary, arg.MaxSalary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeesAdvancedRow
	for rows.Next() {
		var i GetEmployeesAdvancedRow
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Department,
			&i.Salary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmployeesWithAccounts = `-- name: GetEmployeesWithAccounts :many
SELECT 
    e.first_name as employee_name,
    e.department as dept,
    COALESCE(COUNT(a.id), 0)::bigint as account_count,
    COALESCE(SUM(a.balance), 0)::numeric as total_balance
FROM employees e
LEFT JOIN accounts a ON a.owner_id = e.id
WHERE e.department = $1
AND e.salary >= $2
AND e.salary <= $3
GROUP BY e.first_name, e.department
ORDER BY total_balance DESC
`

type GetEmployeesWithAccountsParams struct {
	Department pgtype.Text    `db:"department" json:"department"`
	MinSalary  pgtype.Numeric `db:"min_salary" json:"min_salary"`
	MaxSalary  pgtype.Numeric `db:"max_salary" json:"max_salary"`
}

type GetEmployeesWithAccountsRow struct {
	EmployeeName string         `db:"employee_name" json:"employee_name"`
	Dept         pgtype.Text    `db:"dept" json:"dept"`
	AccountCount int64          `db:"account_count" json:"account_count"`
	TotalBalance pgtype.Numeric `db:"total_balance" json:"total_balance"`
}

func (q *Queries) GetEmployeesWithAccounts(ctx context.Context, arg GetEmployeesWithAccountsParams) ([]GetEmployeesWithAccountsRow, error) {
	rows, err := q.db.Query(ctx, getEmployeesWithAccounts, arg.Department, arg.MinSalary, arg.MaxSalary)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmployeesWithAccountsRow
	for rows.Next() {
		var i GetEmployeesWithAccountsRow
		if err := rows.Scan(
			&i.EmployeeName,
			&i.Dept,
			&i.AccountCount,
			&i.TotalBalance,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uCCList = `-- name: UCCList :many
SELECT
    u.ucc_id,
    u.client_code,
    u.member_code,
    ts.tax_name AS tax_status,
    crm.entity_key AS holding_nature,
    ucc_status.entity_key AS ucc_status,
    u.is_client_physical,
    u.is_client_demat,
    u.parent_client_code,
    COALESCE(
        CASE
            WHEN pd.first_name IS NOT NULL THEN CONCAT(pd.first_name, ' ', pd.middle_name, ' ', pd.last_name)
            WHEN nid.org_name IS NOT NULL THEN nid.org_name
            ELSE ''
        END, 
    '') AS primary_holder_name
FROM
    ucc u
LEFT JOIN
    holder h ON u.ucc_id = h.ref_id 
    AND h.holder_rank = (
        SELECT id 
        FROM common_reference_master 
        WHERE entity = 'UCC_HOLDER_RANK' 
          AND entity_key = 'FIRST'
    )
    AND h.deleted_at IS NULL 
    AND h.deleted_by IS NULL
LEFT JOIN
    person_detail pd ON pd.ref_id = h.id AND h.ref_id = u.ucc_id AND pd.entity_type = 'HOLDER'
LEFT JOIN 
    non_individual_detail nid ON nid.ref_id = h.id AND nid.entity_type = 'HOLDER'
LEFT JOIN
    common_reference_master AS crm ON u.holding_nature = crm.id AND crm.entity = 'UCC_HOLDING_TYPE'
LEFT JOIN
    common_reference_master AS ucc_status ON u.ucc_status = ucc_status.id AND ucc_status.entity = 'UCC_ACC_STATUS'
LEFT JOIN
    tax_status_master AS ts ON u.tax_status = ts.id
WHERE
    -- For integer params, NULL means no filter:
    ($1::bigint IS NULL OR u.ucc_status = $1::bigint) AND
    ($2::bigint IS NULL OR u.tax_status = $2::bigint) AND
    ($3::bigint IS NULL OR u.holding_nature = $3::bigint) AND

    -- For boolean params, NULL means no filter:
    ($4::boolean IS NULL OR u.is_client_physical = $4::boolean) AND
    ($5::boolean IS NULL OR u.is_client_demat = $5::boolean) AND
    NOT (u.is_client_physical = false AND u.is_client_demat = false) AND

    u.deleted_at IS NULL AND u.deleted_by IS NULL AND

    -- For text params, NULL or '' means no filter:
    ($6::text IS NULL OR $6::text = '' OR u.client_code ILIKE $6::text || '%') AND
    ($7::text IS NULL OR $7::text = '' OR u.member_code ILIKE $7::text || '%') AND
    ($8::text IS NULL OR $8::text = '' OR u.parent_client_code ILIKE $8::text || '%') AND
    (
        $9::text IS NULL
        OR $9::text = ''
        OR (
            CONCAT_WS(' ', 
                u.client_code,  
                u.member_code,
                u.parent_client_code,
                ts.tax_name, 
                crm.entity_key,
                COALESCE(
                    pd.first_name || ' ' || pd.middle_name || ' ' || pd.last_name,
                    nid.org_name
                ),
                ucc_status.entity_key,
                CASE WHEN u.is_client_physical THEN 'true' ELSE 'false' END,
                CASE WHEN u.is_client_demat THEN 'true' ELSE 'false' END,
                COALESCE(pd.first_name, nid.org_name)
            ) ILIKE '%' || $9::text || '%'
        )
    )
ORDER BY
    CASE 
        WHEN $10 = 'ucc_id' AND upper($11) = 'A' THEN u.ucc_id
    END ASC,
    CASE 
        WHEN $10 = 'ucc_id' AND upper($11) = 'D' THEN u.ucc_id
    END DESC,
    CASE
        WHEN $10 = 'client_code' AND upper($11) = 'A' THEN u.client_code
    END ASC,
    CASE 
        WHEN $10 = 'client_code' AND upper($11) = 'D' THEN u.client_code
    END DESC,
    CASE
        WHEN $10 = 'member_code' AND upper($11) = 'A' THEN u.member_code
    END ASC,
    CASE 
        WHEN $10 = 'member_code' AND upper($11) = 'D' THEN u.member_code
    END DESC,
    CASE
        WHEN $10 = 'tax_status' AND upper($11) = 'A' THEN ts.tax_name
    END ASC,
    CASE 
        WHEN $10 = 'tax_status' AND upper($11) = 'D' THEN ts.tax_name
    END DESC,
    CASE
        WHEN $10 = 'primary_holder_name' AND upper($11) = 'A' THEN COALESCE(pd.first_name, nid.org_name)
    END ASC,
    CASE 
        WHEN $10 = 'primary_holder_name' AND upper($11) = 'D' THEN COALESCE(pd.first_name, nid.org_name)
    END DESC
OFFSET $12::int
LIMIT $13::int
`

type UCCListParams struct {
	UccStatus        pgtype.Int8 `db:"ucc_status" json:"ucc_status"`
	TaxStatus        pgtype.Int8 `db:"tax_status" json:"tax_status"`
	HoldingNature    pgtype.Int8 `db:"holding_nature" json:"holding_nature"`
	IsClientPhysical pgtype.Bool `db:"is_client_physical" json:"is_client_physical"`
	IsClientDemat    pgtype.Bool `db:"is_client_demat" json:"is_client_demat"`
	ClientCode       pgtype.Text `db:"client_code" json:"client_code"`
	MemberCode       pgtype.Text `db:"member_code" json:"member_code"`
	ParentClientCode pgtype.Text `db:"parent_client_code" json:"parent_client_code"`
	Search           pgtype.Text `db:"search" json:"search"`
	SortBy           interface{} `db:"sort_by" json:"sort_by"`
	SortOrder        interface{} `db:"sort_order" json:"sort_order"`
	Offset           pgtype.Int4 `db:"offset" json:"offset"`
	Limit            pgtype.Int4 `db:"limit" json:"limit"`
}

type UCCListRow struct {
	UccID             int64       `db:"ucc_id" json:"ucc_id"`
	ClientCode        pgtype.Text `db:"client_code" json:"client_code"`
	MemberCode        pgtype.Text `db:"member_code" json:"member_code"`
	TaxStatus         pgtype.Text `db:"tax_status" json:"tax_status"`
	HoldingNature     pgtype.Text `db:"holding_nature" json:"holding_nature"`
	UccStatus         pgtype.Text `db:"ucc_status" json:"ucc_status"`
	IsClientPhysical  bool        `db:"is_client_physical" json:"is_client_physical"`
	IsClientDemat     bool        `db:"is_client_demat" json:"is_client_demat"`
	ParentClientCode  pgtype.Text `db:"parent_client_code" json:"parent_client_code"`
	PrimaryHolderName interface{} `db:"primary_holder_name" json:"primary_holder_name"`
}

func (q *Queries) UCCList(ctx context.Context, arg UCCListParams) ([]UCCListRow, error) {
	rows, err := q.db.Query(ctx, uCCList,
		arg.UccStatus,
		arg.TaxStatus,
		arg.HoldingNature,
		arg.IsClientPhysical,
		arg.IsClientDemat,
		arg.ClientCode,
		arg.MemberCode,
		arg.ParentClientCode,
		arg.Search,
		arg.SortBy,
		arg.SortOrder,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UCCListRow
	for rows.Next() {
		var i UCCListRow
		if err := rows.Scan(
			&i.UccID,
			&i.ClientCode,
			&i.MemberCode,
			&i.TaxStatus,
			&i.HoldingNature,
			&i.UccStatus,
			&i.IsClientPhysical,
			&i.IsClientDemat,
			&i.ParentClientCode,
			&i.PrimaryHolderName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
